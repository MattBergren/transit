{"version":3,"sources":["vendor/lockrroom.js"],"names":["window","lockrRoom","data","loaded","getInitialStore","config","initial","initialState","console","error","ref","path","set","pathData","create","keyToCreate","i","length","undefined","persist","push","Array","isArray","unshift","remove","key","splice"],"mappings":"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","file":"lockrroom.js","sourcesContent":["(function() {\n\n    window.lockrRoom = {\n\n        data: null,\n        loaded: false,\n\n        // initialization function\n        getInitialStore: function(config) {\n\n            let initial\n\n            if (config.initialState) {\n                initial = config.initialState\n                // Lockr.set('$', initial)\n                this.data = initial\n            } else {\n                console.error('Initial state not passed to getInitialStore')\n            }\n\n            this.loaded = true\n            return initial\n        },\n\n        // ref\n        // Returns a reference to the query's state location\n        //\n\n        ref: function(path, set = false) {\n            let pathData = this.data,\n            create = false,\n            keyToCreate\n\n            for (let i = 0; i < path.length; i++) {\n                if (set) {\n                    if (pathData[path[i]] !== undefined) {\n                        pathData = pathData[path[i]]\n                    } else {\n                        if (i+1 === path.length) {\n                            keyToCreate = path[i]\n                            create = true\n                        } else {\n                            console.error('When using set(), you can only create a branch one level deeper than an already created branch. \\nYour path fails because it contains more than one uncreated branch: \\n--' + path)\n                            break\n                        }\n                    }\n                } else {\n                    pathData = pathData[path[i]]\n                }\n            }\n\n            if (pathData === undefined) {\n                console.error('Tried to update the store in a location that does not exist: \\n--' + path)\n            }\n\n            return {\n                data: pathData !== undefined ? pathData : undefined,\n                keyToCreate: keyToCreate !== undefined ? keyToCreate : null,\n                create: create !== undefined ? create : null\n            }\n        },\n\n\n        // persist\n        // Save current store state to LocalStorage with Lockr.\n        // Should only need to be used internally by API\n\n        persist: function() {\n            // dont do this for this project.\n            // Lockr.set('$', this.data)\n        },\n\n        // set\n        // Write or replace data to a defined path, such as product/meta/prices.\n        //\n\n        set: function(path, data) {\n            // pass true as second argument to .ref() to indicate this may be referencing a new branch\n            let pathData = this.ref(path, true)\n\n            if (pathData.data === undefined) {\n                console.error('Set failed.')\n                return false\n            } else {\n                if (pathData.create) {\n                    pathData.data[pathData.keyToCreate] = data\n                } else {\n                    if (typeof pathData.data === 'object') {\n                        pathData.data = Object.assign(pathData.data, data)\n                    } else {\n                        pathData.data = data\n                    }\n\n                }\n                this.persist()\n            }\n        },\n\n        // push\n        // Add to the end of a list of data. Push can only be used on an array.\n        //\n\n        push: function(path, data) {\n            let pathData = this.ref(path).data\n\n            if (pathData === undefined) {\n                console.error('Push failed.')\n                return false\n            } else {\n                if (Array.isArray(pathData)) {\n                    pathData.push(data)\n                    this.persist()\n                } else {\n                    console.error('\\'Push\\' can only be used on an array.')\n                }\n            }\n        },\n\n\n        // unshift\n        // Add to beginning of a list of data. Unshift can only be used on an array.\n        //\n\n        unshift: function(path, data) {\n            let pathData = this.ref(path).data\n\n            if (pathData === undefined) {\n                console.error('Unshift failed.')\n                return false\n            } else {\n                if (Array.isArray(pathData)) {\n                    pathData.unshift(data)\n                    this.persist()\n                } else {\n                    console.error('\\'Unshift\\' can only be used on an array.')\n                }\n            }\n        },\n\n\n        //\n        // remove\n        // Remove data from a specific location\n        // This is a curried function, so you must pass two sets of ()'s when you call it.\n        // The first () contains an argument that is the key which you wish to delete, and the second () contains the path to the parent of that key.\n        //\n\n        remove: function(key) {\n            return path => {\n                let pathData = this.ref(path).data\n                if (pathData === undefined) {\n                    console.error('Remove failed.')\n                    return false\n                } else {\n                    if (pathData[key] === undefined) {\n                        console.error('Remove failed. Key not present in data path.')\n                        return false\n                    } else {\n                        if (Array.isArray(pathData)) {\n                            pathData.splice(key, 1)\n                        } else {\n                            delete pathData[key]\n                        }\n                        this.persist()\n                    }\n                }\n            }\n        }\n    }\n\n    return lockrRoom;\n\n})()\n"]}